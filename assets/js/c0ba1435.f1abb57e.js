"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[1105],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),c=a,h=u["".concat(p,".").concat(c)]||u[c]||m[c]||o;return n?r.createElement(h,i(i({ref:t},d),{},{components:n})):r.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6138:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const o={id:"remix",title:"Remix"},i=void 0,s={unversionedId:"advanced-tutorials/ssr/remix",id:"version-3.xx.xx/advanced-tutorials/ssr/remix",title:"Remix",description:"refine can be used with Remix to SSR your pages. It doesn't get in the way and follows Remix conventions and also provides helper modules when necessary.",source:"@site/versioned_docs/version-3.xx.xx/advanced-tutorials/ssr/remix.md",sourceDirName:"advanced-tutorials/ssr",slug:"/advanced-tutorials/ssr/remix",permalink:"/docs/3.xx.xx/advanced-tutorials/ssr/remix",draft:!1,editUrl:"https://github.com/devdocsorg/devdocs/tree/master/versioned_docs/version-3.xx.xx/advanced-tutorials/ssr/remix.md",tags:[],version:"3.xx.xx",lastUpdatedBy:"ashishdevdocs",lastUpdatedAt:1684241945,formattedLastUpdatedAt:"May 16, 2023",frontMatter:{id:"remix",title:"Remix"},sidebar:"someSidebar",previous:{title:"Table Search",permalink:"/docs/3.xx.xx/advanced-tutorials/search/table-search"},next:{title:"Next.js",permalink:"/docs/3.xx.xx/advanced-tutorials/ssr/nextjs"}},p={},l=[{value:"Setup",id:"setup",level:2},{value:"Usage",id:"usage",level:2},{value:"Custom Route",id:"custom-route",level:2},{value:"SSR",id:"ssr",level:3},{value:"Standard CRUD Page",id:"standard-crud-page",level:2},{value:"SSR",id:"ssr-1",level:3},{value:"Server Side Authentication",id:"server-side-authentication",level:2},{value:"createCookieSessionStorage",id:"createcookiesessionstorage",level:3},{value:"Self service Cookie",id:"self-service-cookie",level:3},{value:"<code>syncWithLocation</code> and Query Parameters in SSR",id:"syncwithlocation-and-query-parameters-in-ssr",level:2},{value:"Examples",id:"examples",level:2}],d={toc:l},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"refine")," can be used with ",(0,a.kt)("a",{parentName:"p",href:"https://remix.run/"},(0,a.kt)("strong",{parentName:"a"},"Remix"))," to SSR your pages. It doesn't get in the way and follows Remix conventions and also provides helper modules when necessary."),(0,a.kt)("h2",{id:"setup"},"Setup"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm i @pankod/refine-core @pankod/refine-remix-router @pankod/refine-simple-rest\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"We recommend using ",(0,a.kt)("inlineCode",{parentName:"p"},"create refine-app")," to initialize your refine projects. It configures the project according to your needs including SSR with Remix!"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"npm create refine-app@latest -- -o refine-remix my-refine-remix-app\n"))),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"<Refine>")," should wrap your ",(0,a.kt)("inlineCode",{parentName:"p"},"<Outlet>")," component located in ",(0,a.kt)("inlineCode",{parentName:"p"},"app/root.tsx"),". This way your ",(0,a.kt)("a",{parentName:"p",href:"https://remix.run/docs/en/v1/api/conventions#routes"},"routes")," are integrated to ",(0,a.kt)("strong",{parentName:"p"},"refine"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/root.tsx"',title:'"app/root.tsx"'},"import type { MetaFunction } from '@remix-run/node'\nimport {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react'\n// highlight-start\nimport { Refine } from '@pankod/refine-core'\nimport dataProvider from '@pankod/refine-simple-rest'\nimport routerProvider from '@pankod/refine-remix-router'\n// highlight-end\n\nexport const meta: MetaFunction = () => ({\n  charset: 'utf-8',\n  title: 'New Remix + Refine App',\n  viewport: 'width=device-width,initial-scale=1',\n})\n\n// highlight-next-line\nconst API_URL = 'https://api.fake-rest.refine.dev'\n\nexport default function App() {\n  return (\n    <html lang=\"en\">\n      <head>\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        // highlight-start\n        <Refine\n          dataProvider={dataProvider(API_URL)}\n          routerProvider={routerProvider}\n        >\n          <Outlet />\n        </Refine>\n        // highlight-end\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  )\n}\n")),(0,a.kt)("h2",{id:"custom-route"},"Custom Route"),(0,a.kt)("p",null,"Let's say we want to show a list of users in ",(0,a.kt)("inlineCode",{parentName:"p"},"/posts"),". After creating ",(0,a.kt)("inlineCode",{parentName:"p"},"posts.tsx")," under ",(0,a.kt)("inlineCode",{parentName:"p"},"routes")," in your Remix app, we can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"useTable")," hook to list the users in a table:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="routes/posts.tsx"',title:'"routes/posts.tsx"'},"import { LayoutWrapper, useTable } from '@pankod/refine-core'\n\nexport const PostList: React.FC = () => {\n  const { tableQueryResult } = useTable<IPost>({\n    resource: 'posts',\n  })\n\n  return (\n    <LayoutWrapper>\n      <table>\n        <thead>\n          <tr>\n            <th>ID</th>\n            <th>Title</th>\n            <th>Status</th>\n          </tr>\n        </thead>\n        <tbody>\n          {tableQueryResult.data?.data.map((post) => (\n            <tr key={post.id}>\n              <td>{post.id}</td>\n              <td>{post.title}</td>\n              <td>{post.status}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </LayoutWrapper>\n  )\n}\n\ninterface IPost {\n  id: number\n  title: string\n  status: string\n}\n\nexport default PostList\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"If you want to handle your ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," with a custom route or create a custom route with or without a resource, these will not be visible in the ",(0,a.kt)("inlineCode",{parentName:"p"},"<Sider />")," component. You can trick the ",(0,a.kt)("inlineCode",{parentName:"p"},"<Sider/>")," by passing an empty resource to show your custom route in it."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="Example"',title:'"Example"'},"const App = () => (\n  <Refine\n    resources={[\n      // This will add an item to `<Sider/>` with route `/my-custom-item`\n      { name: 'my-custom-item', list: () => null },\n    ]}\n  />\n)\n"))),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Notice how we passed ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," prop to ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/core/hooks/useTable"},(0,a.kt)("inlineCode",{parentName:"a"},"useTable")),". This is necessary since for ",(0,a.kt)("inlineCode",{parentName:"p"},"useTable")," to be able to get ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," name from the route, it needs to be a route parameter in a dynamic route. ",(0,a.kt)("a",{parentName:"p",href:"#standard-crud-page"},"Refer here")," where standard CRUD pages can be built with dynamic routing.")),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"We also used ",(0,a.kt)("inlineCode",{parentName:"p"},"<LayoutWrapper>")," to show the page in the layout provided to ",(0,a.kt)("a",{parentName:"p",href:"/docs/3.xx.xx/api-reference/core/components/refine-config"},(0,a.kt)("inlineCode",{parentName:"a"},"<Refine>")),". This is deliberately opt-in to provide flexibility. ",(0,a.kt)("a",{parentName:"p",href:"#standart-crud-page"},"If you're building a standard CRUD page layout can be baked in automatically"),".")),(0,a.kt)("h3",{id:"ssr"},"SSR"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"refine")," uses ",(0,a.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/"},"react-query")," in its hooks for data management. ",(0,a.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/guides/ssr#using-initialdata"},"Following react-query's guide"),", SSR can be achieved like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="routes/posts.tsx"',title:'"routes/posts.tsx"'},"// highlight-start\nimport { json, LoaderFunction } from '@remix-run/node'\nimport { useLoaderData } from '@remix-run/react'\n// highlight-end\n\nimport { LayoutWrapper, useTable } from '@pankod/refine-core'\n\n// highlight-next-line\nimport dataProvider from '@pankod/refine-simple-rest'\n\nexport const PostList: React.FC = () => {\n  // highlight-next-line\n  const { initialData } = useLoaderData()\n\n  const { tableQueryResult } = useTable<IPost>({\n    resource: 'posts',\n    // highlight-start\n    queryOptions: {\n      initialData,\n    },\n    // highlight-end\n  })\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Title</th>\n          <th>Status</th>\n        </tr>\n      </thead>\n      <tbody>\n        {tableQueryResult.data?.data.map((post) => (\n          <tr key={post.id}>\n            <td>{post.id}</td>\n            <td>{post.title}</td>\n            <td>{post.status}</td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  )\n}\n\n// highlight-start\nexport const loader: LoaderFunction = async ({ params, request, context }) => {\n  const API_URL = 'https://api.fake-rest.refine.dev'\n\n  try {\n    const data = await dataProvider(API_URL).getList({\n      resource: 'posts',\n    })\n\n    return json({ initialData: data })\n  } catch (error) {\n    return json({})\n  }\n}\n// highlight-end\n\ninterface IPost {\n  id: number\n  title: string\n  status: string\n}\n\nexport default PostList\n")),(0,a.kt)("p",null,"We use the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/core/providers/data-provider/#getlist-"},(0,a.kt)("inlineCode",{parentName:"a"},"getList"))," method from our ",(0,a.kt)("a",{parentName:"p",href:"/docs/3.xx.xx/api-reference/core/providers/data-provider"},(0,a.kt)("inlineCode",{parentName:"a"},"dataProvider"))," to fetch ",(0,a.kt)("inlineCode",{parentName:"p"},"posts")," data and pass through ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," as conventionally done in Remix. Then ",(0,a.kt)("inlineCode",{parentName:"p"},"posts")," data is available in the props of our ",(0,a.kt)("inlineCode",{parentName:"p"},"/posts")," page. ",(0,a.kt)("a",{parentName:"p",href:"/docs/api-reference/core/hooks/useTable"},(0,a.kt)("inlineCode",{parentName:"a"},"useTable"))," can take options for underlying react-query queries with ",(0,a.kt)("inlineCode",{parentName:"p"},"queryOptions"),". Passing ",(0,a.kt)("inlineCode",{parentName:"p"},"posts")," data to its ",(0,a.kt)("inlineCode",{parentName:"p"},"initialData")," loads the data on server side."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"We used ",(0,a.kt)("inlineCode",{parentName:"p"},"getList")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"dataProvider")," but data can be fetched in any way you desire.")),(0,a.kt)("h2",{id:"standard-crud-page"},"Standard CRUD Page"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"@pankod/refine-remix-router")," package provides ",(0,a.kt)("inlineCode",{parentName:"p"},"RemixRouteComponent")," for routing in ",(0,a.kt)("strong",{parentName:"p"},"refine")," resources. Simply export the component from the page and add a ",(0,a.kt)("a",{parentName:"p",href:"https://remix.run/docs/en/v1/api/conventions#loader"},"loader function"),". While you can create pages with defined params like ",(0,a.kt)("inlineCode",{parentName:"p"},"$resource/$action/$id.tsx"),", we recommend using a splat route to handle all refine routing in a single file. You can start by creating a ",(0,a.kt)("inlineCode",{parentName:"p"},"$.tsx")," file under ",(0,a.kt)("inlineCode",{parentName:"p"},"app/routes")," in your Remix app:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/$.tsx"',title:'"app/routes/$.tsx"'},"export { RemixRouteComponent as default } from '@pankod/refine-remix-router'\n")),(0,a.kt)("p",null,"Remix, does not handle the root ",(0,a.kt)("inlineCode",{parentName:"p"},"/")," route in splat routes. So we also need to create a ",(0,a.kt)("inlineCode",{parentName:"p"},"index.tsx")," file under ",(0,a.kt)("inlineCode",{parentName:"p"},"app/routes")," with the same content:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/index.tsx"',title:'"app/routes/index.tsx"'},"export { RemixRouteComponent as default } from '@pankod/refine-remix-router'\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"You can also define routes without using ",(0,a.kt)("inlineCode",{parentName:"p"},"$.tsx")," file like below, but a splat route is an easier approach with nested route support."),(0,a.kt)("p",{parentName:"admonition"},"Export ",(0,a.kt)("inlineCode",{parentName:"p"},"RemixRouteComponent")," as default in the following pages:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"routes/$resource/index.tsx")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"routes/$resource/$action/index.tsx")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"routes/$resource/$action/$id/index.tsx")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"routes/index.tsx"))),(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"RemixRouteComponent")," will use route parameters ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," and render the associated component defined in ",(0,a.kt)("a",{parentName:"p",href:"/docs/3.xx.xx/api-reference/core/components/refine-config"},(0,a.kt)("inlineCode",{parentName:"a"},"resources")),"."),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"list")," component will be rendered for ",(0,a.kt)("inlineCode",{parentName:"li"},"/$resource")," route"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"create"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"edit")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"show")," will be rendered for ",(0,a.kt)("inlineCode",{parentName:"li"},"/$resource/$action")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"/$resource/$action/$id")," routes"),(0,a.kt)("li",{parentName:"ul"},"For the root ",(0,a.kt)("inlineCode",{parentName:"li"},"/")," route, it will render ",(0,a.kt)("inlineCode",{parentName:"li"},"DashboardPage")," if it's defined and if not will navigate to the first resource in ",(0,a.kt)("inlineCode",{parentName:"li"},"resources"),"."))),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("inlineCode",{parentName:"p"},"RemixRouteComponent")," will wrap the page with ",(0,a.kt)("inlineCode",{parentName:"p"},"Layout")," provided to ",(0,a.kt)("a",{parentName:"p",href:"/docs/3.xx.xx/api-reference/core/components/refine-config"},(0,a.kt)("inlineCode",{parentName:"a"},"<Refine>")))),(0,a.kt)("h3",{id:"ssr-1"},"SSR"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"RemixRouteComponent")," accepts an ",(0,a.kt)("inlineCode",{parentName:"p"},"initialData")," prop for SSR data."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type RemixRouteComponentProps = {\n  initialData?: any\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"initialData")," must be passed as props from ",(0,a.kt)("inlineCode",{parentName:"p"},"loader"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"RemixRouteComponent")," will pass this data as ",(0,a.kt)("inlineCode",{parentName:"p"},"initialData")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"create"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"edit"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"show")," components."),(0,a.kt)("p",null,"For example, for a ",(0,a.kt)("inlineCode",{parentName:"p"},"list")," component that will be rendered for ",(0,a.kt)("inlineCode",{parentName:"p"},"/$.tsx"),", the page can use SSR like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/$.tsx"',title:'"app/routes/$.tsx"'},"import { json, LoaderFunction } from '@remix-run/node'\nimport dataProvider from '@pankod/refine-simple-rest'\nimport { handleRefineParams } from '@pankod/refine-remix-router'\n\nexport { RemixRouteComponent as default } from '@pankod/refine-remix-router'\n\nconst API_URL = 'https://api.fake-rest.refine.dev'\nexport const loader: LoaderFunction = async ({ params, request }) => {\n  const { resource } = params\n\n  const refineSplatParams = handleRefineParams(params['*'])\n\n  const {\n    resource = undefined,\n    action = undefined,\n    id = undefined,\n  } = { ...refineSplatParams, ...params }\n\n  try {\n    if (resource && action === 'show' && id) {\n      const data = await dataProvider(API_URL).getOne({\n        // we're slicing the resource param to get the resource name from the last part\n        resource: `${resource}`.slice(`${resource}`.lastIndexOf('/') + 1),\n        id,\n      })\n\n      return json({ initialData: data })\n    } else if (resource && !action && !id) {\n      const data = await dataProvider(API_URL).getList({\n        // we're slicing the resource param to get the resource name from the last part\n        resource: `${resource}`.slice(`${resource}`.lastIndexOf('/') + 1),\n      })\n\n      return json({ initialData: data })\n    }\n\n    return null\n  } catch (error) {\n    return json({})\n  }\n}\n")),(0,a.kt)("p",null,"And in the ",(0,a.kt)("inlineCode",{parentName:"p"},"list")," component for a ",(0,a.kt)("inlineCode",{parentName:"p"},"resource"),' e.g. "posts":'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/pages/posts/list.tsx"',title:'"app/pages/posts/list.tsx"'},"// highlight-next-line\nimport { useLoaderData } from '@remix-run/react'\nimport {\n  useTable,\n  GetListResponse,\n  IResourceComponentsProps,\n} from '@pankod/refine-core'\n\nexport const PostList: React.FC<\n  IResourceComponentsProps<GetListResponse<IPost>>\n> = () => {\n  // highlight-next-line\n  const { initialData } = useLoaderData()\n\n  const { tableQueryResult } = useTable<IPost>({\n    // highlight-start\n    queryOptions: {\n      initialData,\n    },\n    // highlight-end\n  })\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Title</th>\n          <th>Status</th>\n        </tr>\n      </thead>\n      <tbody>\n        {tableQueryResult?.data?.data.map((post) => (\n          <tr key={post.id}>\n            <td>{post.id}</td>\n            <td>{post.title}</td>\n            <td>{post.status}</td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  )\n}\n\ninterface IPost {\n  id: number\n  title: string\n  status: string\n}\n")),(0,a.kt)("p",null,"Finally, let's give our ",(0,a.kt)("inlineCode",{parentName:"p"},"PostList")," page as a ",(0,a.kt)("inlineCode",{parentName:"p"},"resource")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"<Refine>")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/root.tsx"',title:'"app/root.tsx"'},"import type { MetaFunction } from '@remix-run/node'\nimport {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react'\nimport { Refine } from '@pankod/refine-core'\nimport dataProvider from '@pankod/refine-simple-rest'\nimport routerProvider from '@pankod/refine-remix-router'\n\nimport { PostList } from './pages/posts/list'\n\nexport const meta: MetaFunction = () => ({\n  charset: 'utf-8',\n  title: 'New Remix + Refine App',\n  viewport: 'width=device-width,initial-scale=1',\n})\n\nconst API_URL = 'https://api.fake-rest.refine.dev'\n\nexport default function App() {\n  return (\n    <html lang=\"en\">\n      <head>\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <Refine\n          dataProvider={dataProvider(API_URL)}\n          routerProvider={routerProvider}\n          resources={[\n            {\n              name: 'posts',\n              list: PostList,\n            },\n          ]}\n        >\n          <Outlet />\n        </Refine>\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  )\n}\n")),(0,a.kt)("h2",{id:"server-side-authentication"},"Server Side Authentication"),(0,a.kt)("p",null,"There are two ways to do Server Side Authentication with Remix. You can choose one of the two methods according to your use case."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"You can store the user session as encrypted using ",(0,a.kt)("inlineCode",{parentName:"li"},"createCookieSessionStorage"),". When you choose this method, all authentication information will remain on the server side."),(0,a.kt)("li",{parentName:"ol"},"Self service cookies! You manage authentication cookies yourself. The plus of this method is that the Authentication information can also be used on the Client Side. (recommended)")),(0,a.kt)("h3",{id:"createcookiesessionstorage"},"createCookieSessionStorage"),(0,a.kt)("p",null,"First, let's create our ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthProvider"),". For more information on ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthProvider"),", visit our ",(0,a.kt)("a",{parentName:"p",href:"/docs/3.xx.xx/api-reference/core/providers/auth-provider"},"AuthProvider documentation"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/authProvider.ts"',title:'"app/authProvider.ts"'},"import { AuthProvider } from '@pankod/refine-core'\n\nconst mockUsers = [\n  {\n    username: 'admin',\n    roles: ['admin'],\n  },\n  {\n    username: 'editor',\n    roles: ['editor'],\n  },\n]\n\nexport const authProvider: AuthProvider = {\n  login: ({ username, password, remember }) => {\n    // Suppose we actually send a request to the back end here.\n    const user = mockUsers.find((item) => item.username === username)\n\n    if (user) {\n      return Promise.resolve(user)\n    }\n\n    return Promise.reject()\n  },\n  logout: () => {\n    return Promise.resolve('/logout')\n  },\n  checkError: (error) => {\n    if (error && error.statusCode === 401) {\n      return Promise.reject()\n    }\n\n    return Promise.resolve()\n  },\n  checkAuth: async ({ request, storage }) => {\n    const session = await storage.getSession(request.headers.get('Cookie'))\n\n    const user = session.get('user')\n\n    if (!user) {\n      return Promise.reject()\n    }\n    return Promise.resolve()\n  },\n  getPermissions: async () => {\n    return Promise.resolve()\n  },\n  getUserIdentity: async () => {\n    return Promise.resolve()\n  },\n}\n")),(0,a.kt)("p",null,"Next, let's create the ",(0,a.kt)("inlineCode",{parentName:"p"},"app/session.server.ts")," file as mentioned in the ",(0,a.kt)("a",{parentName:"p",href:"https://remix.run/docs/en/v1/tutorials/jokes#authentication"},(0,a.kt)("inlineCode",{parentName:"a"},"Jokes App"))," tutorial"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/session.server.ts"',title:'"app/session.server.ts"'},"import { createCookieSessionStorage, redirect } from '@remix-run/node'\nimport { authProvider } from './authProvider'\n\ntype LoginForm = {\n  username: string\n  password: string\n}\n\n// normally you want this to be env variable\nconst sessionSecret = 'SUPER_SECRET_SESSION' //process.env.SESSION_SECRET;\nif (!sessionSecret) {\n  throw new Error('SESSION_SECRET must be set')\n}\n\nconst storage = createCookieSessionStorage({\n  cookie: {\n    name: 'RJ_session',\n    // normally you want this to be `secure: true`\n    // but that doesn't work on localhost for Safari\n    // https://web.dev/when-to-use-local-https/\n    secure: process.env.NODE_ENV === 'production',\n    secrets: [sessionSecret],\n    sameSite: 'lax',\n    path: '/',\n    maxAge: 60 * 60 * 24 * 30,\n    httpOnly: true,\n  },\n})\n\nexport async function login({ username, password }: LoginForm) {\n  try {\n    const user = await authProvider.login({ username, password })\n    if (user) {\n      return { user }\n    }\n  } catch (error) {\n    return error\n  }\n}\n\nexport async function requireUserId(\n  request: Request,\n  redirectTo: string = new URL(request.url).pathname,\n) {\n  try {\n    const user = await authProvider.checkAuth?.({ request, storage })\n    return user\n  } catch (error) {\n    const searchParams = new URLSearchParams([['to', redirectTo]])\n    throw redirect(`/login?${searchParams}`)\n  }\n}\n\nexport async function createUserSession(user: object, redirectTo: string) {\n  const session = await storage.getSession()\n  session.set('user', { ...user })\n  return redirect(redirectTo, {\n    headers: {\n      'Set-Cookie': await storage.commitSession(session),\n    },\n  })\n}\n\nexport async function logout(request: Request) {\n  const session = await storage.getSession(request.headers.get('Cookie'))\n  return redirect('/login', {\n    headers: {\n      'Set-Cookie': await storage.destroySession(session),\n    },\n  })\n}\n")),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"login")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"requireUserId")," functions, we call the corresponding functions of our ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthProvider"),"."),(0,a.kt)("p",null,"Now let's create our login page"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/login.tsx"',title:'"app/routes/login.tsx"'},"import React from 'react'\nimport { useTranslate } from '@pankod/refine-core'\n\nimport { login, createUserSession } from '~/session.server'\nimport { ActionFunction } from '@remix-run/node'\nimport { useSearchParams } from '@remix-run/react'\n\nexport interface ILoginForm {\n  username: string\n  password: string\n}\n\nconst LoginPage: React.FC = () => {\n  const translate = useTranslate()\n  const [searchParams] = useSearchParams()\n\n  return (\n    <>\n      <h1>{translate('pages.login.title', 'Sign in your account')}</h1>\n      <form method=\"post\">\n        <input\n          type=\"hidden\"\n          name=\"redirectTo\"\n          value={searchParams.get('to') ?? undefined}\n        />\n        <table>\n          <tbody>\n            <tr>\n              <td>\n                {translate('pages.login.username', undefined, 'username')}:\n              </td>\n              <td>\n                <input\n                  name=\"username\"\n                  type=\"text\"\n                  size={20}\n                  autoCorrect=\"off\"\n                  spellCheck={false}\n                  autoCapitalize=\"off\"\n                  autoFocus\n                  required\n                />\n              </td>\n            </tr>\n            <tr>\n              <td>\n                {translate('pages.login.password', undefined, 'password')}:\n              </td>\n              <td>\n                <input type=\"password\" name=\"password\" required size={20} />\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <br />\n        <input type=\"submit\" value=\"login\" />\n      </form>\n    </>\n  )\n}\n\nexport const action: ActionFunction = async ({ request }) => {\n  const form = await request.formData()\n  const username = form.get('username') as string\n  const password = form.get('password') as string\n  const redirectTo = form.get('redirectTo') || '/'\n  // highlight-start\n  const user = await login({ username, password })\n  if (!user) {\n    return null\n  }\n\n  return createUserSession(user as any, redirectTo as string)\n  // highlight-end\n}\n\nexport default LoginPage\n")),(0,a.kt)("p",null,"Yeeyy! Now our users can login!"),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Remember, actions and loaders run on the server, so console.log calls you put in those you can't see in the browser console. Those will show up in the terminal window you're running your server in.")),(0,a.kt)("p",null,"We can call the ",(0,a.kt)("inlineCode",{parentName:"p"},"requireUserId")," function on our routes where we want the authentication check done."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { json, LoaderFunction } from '@remix-run/node'\n//highlight-next-line\nimport { requireUserId } from '~/session.server'\n\nexport const loader: LoaderFunction = async ({ params, request, context }) => {\n  //highlight-next-line\n  await requireUserId(request)\n\n  return json({})\n}\n")),(0,a.kt)("p",null,"Finally, let's make sure our users can log out. For this, we create a routes for ",(0,a.kt)("inlineCode",{parentName:"p"},"/logout"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/app/routes/logout.tsx"',title:'"/app/routes/logout.tsx"'},"import type { LoaderFunction } from '@remix-run/node'\n\nimport { logout } from '~/session.server'\n\nexport const loader: LoaderFunction = async ({ request }) => {\n  return await logout(request)\n}\n")),(0,a.kt)("h3",{id:"self-service-cookie"},"Self service Cookie"),(0,a.kt)("p",null,"First, let's install the ",(0,a.kt)("inlineCode",{parentName:"p"},"js-cookie")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"cookie")," packages in our project."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"npm i js-cookie cookie\n\n# typescript types\nnpm i -D @types/js-cookie\n")),(0,a.kt)("p",null,"We will set/destroy cookies in the ",(0,a.kt)("inlineCode",{parentName:"p"},"login"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"logout")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"checkAuth")," functions of our ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthProvider"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/authProvider.ts"',title:'"app/authProvider.ts"'},"import { AuthProvider } from '@pankod/refine-core'\n// highlight-start\nimport Cookies from 'js-cookie'\nimport * as cookie from 'cookie'\n// highlight-end\n\nconst mockUsers = [\n  {\n    username: 'admin',\n    roles: ['admin'],\n  },\n  {\n    username: 'editor',\n    roles: ['editor'],\n  },\n]\n\n// highlight-next-line\nconst COOKIE_NAME = 'user'\n\nexport const authProvider: AuthProvider = {\n  login: ({ username, password, remember }) => {\n    // Suppose we actually send a request to the back end here.\n    const user = mockUsers.find((item) => item.username === username)\n\n    if (user) {\n      // highlight-next-line\n      Cookies.set(COOKIE_NAME, JSON.stringify(user))\n      return Promise.resolve()\n    }\n\n    return Promise.reject()\n  },\n  logout: () => {\n    // highlight-next-line\n    Cookies.remove(COOKIE_NAME)\n\n    return Promise.resolve()\n  },\n  checkError: (error) => {\n    if (error && error.statusCode === 401) {\n      return Promise.reject()\n    }\n\n    return Promise.resolve()\n  },\n  checkAuth: async (context) => {\n    // highlight-start\n    let user = undefined\n    if (context) {\n      // for SSR\n      const { request } = context\n      const parsedCookie = cookie.parse(request.headers.get('Cookie'))\n      user = parsedCookie[COOKIE_NAME]\n    } else {\n      // for CSR\n      const parsedCookie = Cookies.get(COOKIE_NAME)\n      user = parsedCookie ? JSON.parse(parsedCookie) : undefined\n    }\n    // highlight-end\n\n    if (!user) {\n      return Promise.reject()\n    }\n    return Promise.resolve()\n  },\n  getPermissions: async () => {\n    return Promise.resolve()\n  },\n  getUserIdentity: async () => {\n    return Promise.resolve()\n  },\n}\n")),(0,a.kt)("p",null,"Tadaa! that's all!"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"checkAuthentication")," expects your authProvider and ",(0,a.kt)("inlineCode",{parentName:"p"},"request"),"'s context. It uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"checkAuth")," from the ",(0,a.kt)("inlineCode",{parentName:"p"},"authProvider")," to check for authentication. In unauthenticated cases, it redirects to ",(0,a.kt)("inlineCode",{parentName:"p"},"/login")," while keeping the original route to be navigated to after successful login."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/index.tsx"',title:'"app/routes/index.tsx"'},"import { json, LoaderFunction } from '@remix-run/node'\nimport { authProvider } from '~/authProvider'\n\n//highlight-next-line\nimport { checkAuthentication } from '@pankod/refine-remix-router'\nexport { RemixRouteComponent as default } from '@pankod/refine-remix-router'\n\nexport const loader: LoaderFunction = async ({ params, request, context }) => {\n  //highlight-next-line\n  await checkAuthentication(authProvider, request)\n  return null\n}\n")),(0,a.kt)("p",null,"You can also add the authentication check to the routes below"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"app/routes/$resource/index.tsx")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"app/routes/$resource/$action/index.tsx")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"app/routes/$resource/$action/$id/index.tsx"))),(0,a.kt)("h2",{id:"syncwithlocation-and-query-parameters-in-ssr"},(0,a.kt)("inlineCode",{parentName:"h2"},"syncWithLocation")," and Query Parameters in SSR"),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"syncWithLocation")," is enabled, query parameters must be handled while doing SSR."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/$resource/index.tsx"',title:'"app/routes/$resource/index.tsx"'},"import { json, LoaderFunction } from '@remix-run/node'\nimport dataProvider from '@pankod/refine-simple-rest'\n// highligt-next-line\nimport { parseTableParams } from '@pankod/refine-core'\n\nexport { RemixRouteComponent as default } from '@pankod/refine-remix-router'\n\nconst API_URL = 'https://api.fake-rest.refine.dev'\nexport const loader: LoaderFunction = async ({ params, request }) => {\n  const { resource } = params\n  const url = new URL(request.url)\n\n  // highligt-next-line\n  const { parsedCurrent, parsedPageSize, parsedSorter, parsedFilters } =\n    parseTableParams(url.search)\n\n  try {\n    const data = await dataProvider(API_URL).getList({\n      resource: resource as string,\n      filters: parsedFilters,\n      pagination: {\n        current: parsedCurrent || 1,\n        pageSize: parsedPageSize || 10,\n      },\n      sort: parsedSorter,\n    })\n\n    return json({ initialData: data })\n  } catch (error) {\n    return json({})\n  }\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"parseTableParams")," parses the query string and returns query parameters(",(0,a.kt)("a",{parentName:"p",href:"/docs/3.xx.xx/api-reference/core/interfaceReferences/#crudfilters"},"refer here for their interfaces"),"). They can be directly used for ",(0,a.kt)("inlineCode",{parentName:"p"},"dataProvider")," methods that accept them."),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://ant.design/"},"Ant Design")," CRUD app example (",(0,a.kt)("a",{parentName:"li",href:"https://github.com/refinedev/refine/tree/master/examples/remix/antd"},"source code"),")"),(0,a.kt)("li",{parentName:"ul"},"Headless CRUD app example (",(0,a.kt)("a",{parentName:"li",href:"https://github.com/refinedev/refine/tree/master/examples/remix/headless"},"source code"),")")))}m.isMDXComponent=!0}}]);