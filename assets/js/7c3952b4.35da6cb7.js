"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[57400],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,h=u["".concat(p,".").concat(m)]||u[m]||c[m]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5419:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={id:"nextjs",title:"Next.js"},i=void 0,s={unversionedId:"packages/documentation/routers/nextjs",id:"packages/documentation/routers/nextjs",title:"Next.js",description:"refine provides router bindings and utilities for Next.js. This package will provide easy integration between refine and Next.js for both existing projects and new projects without giving up the benefits of Next.js.",source:"@site/docs/packages/documentation/routers/nextjs-router.md",sourceDirName:"packages/documentation/routers",slug:"/packages/documentation/routers/nextjs",permalink:"/docs/packages/documentation/routers/nextjs",draft:!1,editUrl:"https://github.com/devdocsorg/devdocs/tree/master/docs/packages/documentation/routers/nextjs-router.md",tags:[],version:"current",lastUpdatedBy:"ashishdevdocs",lastUpdatedAt:1684241945,formattedLastUpdatedAt:"May 16, 2023",frontMatter:{id:"nextjs",title:"Next.js"},sidebar:"someSidebar",previous:{title:"React Router v6",permalink:"/docs/packages/documentation/routers/react-router-v6"},next:{title:"Remix",permalink:"/docs/packages/documentation/routers/remix"}},p={},l=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"<code>/pages</code> Directory",id:"pages-directory",level:3},{value:"<code>/app</code> Directory",id:"app-directory",level:3},{value:"Additional Components",id:"additional-components",level:2},{value:"<code>NavigateToResource</code>",id:"navigatetoresource",level:3},{value:"In <code>pages/index.tsx</code>",id:"in-pagesindextsx",level:4},{value:"In <code>app/page.tsx</code>",id:"in-apppagetsx",level:4},{value:"Properties",id:"properties",level:4},{value:"<code>UnsavedChangesNotifier</code>",id:"unsavedchangesnotifier",level:3},{value:"Properties",id:"properties-1",level:4},{value:"<code>parseTableParams</code>",id:"parsetableparams",level:3},{value:"Authentication",id:"authentication",level:2},{value:"Server Side",id:"server-side",level:3},{value:"Access Control",id:"access-control",level:2},{value:"Server Side",id:"server-side-1",level:3},{value:"Client Side",id:"client-side",level:3},{value:"FAQ",id:"faq",level:2},{value:"Can I use nested routes?",id:"can-i-use-nested-routes",level:3},{value:"How to make SSR work?",id:"how-to-make-ssr-work",level:3},{value:"How to persist <code>syncWithLocation</code> in SSR?",id:"how-to-persist-syncwithlocation-in-ssr",level:3},{value:"How to use multiple layouts?",id:"how-to-use-multiple-layouts",level:3},{value:"Handling 404s",id:"handling-404s",level:3},{value:"Using the Next.js&#39;s 404 page",id:"using-the-nextjss-404-page",level:4},{value:"Using a catch-all route",id:"using-a-catch-all-route",level:4},{value:"<code>RefineRoutes</code> Component",id:"refineroutes-component",level:3},{value:"In <code>pages/[[...refine]].tsx</code>",id:"in-pagesrefinetsx",level:4},{value:"In <code>app/[[...refine]]/page.tsx</code>",id:"in-apprefinepagetsx",level:4}],d=(u="CodeSandboxExample",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var u;const c={toc:l},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"refine")," provides router bindings and utilities for ",(0,r.kt)("a",{parentName:"p",href:"https://nextjs.org/"},"Next.js"),". This package will provide easy integration between ",(0,r.kt)("strong",{parentName:"p"},"refine")," and ",(0,r.kt)("strong",{parentName:"p"},"Next.js")," for both existing projects and new projects without giving up the benefits of ",(0,r.kt)("strong",{parentName:"p"},"Next.js"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm i @refinedev/nextjs-router\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"We recommend using ",(0,r.kt)("inlineCode",{parentName:"p"},"create refine-app")," to initialize your refine projects. It configures the project according to your needs including SSR with Next.js!"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"npm create refine-app@latest -- -o refine-nextjs my-refine-nextjs-app\n"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/providers/router-provider"},"Refer to the Router Provider documentation for detailed information. ","\u2192")),(0,r.kt)("admonition",{title:"Legacy Router",type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/nextjs-router")," also exports the legacy router provider and it will be available until the next major version of ",(0,r.kt)("strong",{parentName:"p"},"refine"),". It is recommended to use the new router provider instead of the legacy one."),(0,r.kt)("p",{parentName:"admonition"},"If you are using the legacy router provider, it can be imported from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/nextjs-router/legacy")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"/pages")," directory and ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/nextjs-router/legacy-app")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"/app")," directory and passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"legacyRouterProvider")," prop of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Refine")," component.")),(0,r.kt)("h2",{id:"basic-usage"},"Basic Usage"),(0,r.kt)("h3",{id:"pages-directory"},(0,r.kt)("inlineCode",{parentName:"h3"},"/pages")," Directory"),(0,r.kt)("p",null,"We'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/nextjs-router")," to set up the router bindings for ",(0,r.kt)("strong",{parentName:"p"},"refine"),". We'll define the action routes for our resources in the ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," array and define our pages in the ",(0,r.kt)("inlineCode",{parentName:"p"},"pages")," directory."),(0,r.kt)("p",null,"We'll create four pages for our resources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pages/posts/index.tsx")," - List page for posts"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pages/posts/show/[id].tsx")," - Detail page for posts"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pages/categories/index.tsx")," - List page for categories"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pages/categories/show/[id].tsx")," - Detail page for categories")),(0,r.kt)("p",null,"And we'll create one page for the index route and use it to redirect to the ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pages/index.tsx")," - Index page")),(0,r.kt)("p",null,"Let's start with the initialization of the ",(0,r.kt)("strong",{parentName:"p"},"refine")," app in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_app.tsx")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=_app.tsx",title:"_app.tsx"},"import { Refine } from '@refinedev/core'\nimport dataProvider from '@refinedev/simple-rest'\nimport routerProvider from '@refinedev/nextjs-router'\n\nimport { Layout } from 'components/Layout'\n\nfunction App({ Component, pageProps }: AppProps): JSX.Element {\n  return (\n    <Refine\n      dataProvider={dataProvider('https://api.fake-rest.refine.dev')}\n      // highlight-next-line\n      routerProvider={routerProvider}\n      resources={[\n        {\n          name: 'posts',\n          list: '/posts',\n          show: '/posts/show/:id',\n        },\n        {\n          name: 'categories',\n          list: '/categories',\n          show: '/categories/show/:id',\n        },\n      ]}\n    >\n      <Layout>\n        <Component {...pageProps} />\n      </Layout>\n    </Refine>\n  )\n}\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Next.js uses the bracket syntax (",(0,r.kt)("inlineCode",{parentName:"p"},"[param]"),") for dynamic routes but ",(0,r.kt)("strong",{parentName:"p"},"refine")," uses the colon syntax (",(0,r.kt)("inlineCode",{parentName:"p"},":param"),") for route parameters. This won't cause any problems since ",(0,r.kt)("strong",{parentName:"p"},"refine")," only uses the colon syntax as an indicator for route parameters and the communication between ",(0,r.kt)("strong",{parentName:"p"},"refine")," and the router is handled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," prop.")),(0,r.kt)("admonition",{title:"Additional Parameters and Nesting",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Your action definitions in the resources can contain additional parameters and nested routes. Passing these parameters when navigating to the pages are handled by the current available parameters and the ",(0,r.kt)("inlineCode",{parentName:"p"},"meta")," props of the related hooks and components."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"refine")," supports route parameters defined with ",(0,r.kt)("inlineCode",{parentName:"p"},":param")," syntax. You can use these parameters in your action definitions and create your routes accordingly. For example, if you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource and you want to create a route for the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," action of a specific post, you can define the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," action as ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts/show/:id")," and use the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," parameter in your component.")),(0,r.kt)("p",null,"Now we can create our pages in the ",(0,r.kt)("inlineCode",{parentName:"p"},"pages")," directory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/posts/index.tsx",title:"pages/posts/index.tsx"},"import { useTable } from '@refinedev/core'\nimport Link from 'next/link'\n\ntype IPost = {\n  id: string\n  title: string\n  description: string\n}\n\nexport default function PostList() {\n  // `posts` resource will be inferred from the route.\n  // Because we've defined `/posts` as the `list` action of the `posts` resource.\n  const {\n    tableQueryResult: { data, isLoading },\n  } = useTable<IPost>()\n\n  const tableData = data?.data\n\n  return (\n    <div>\n      {isLoading && <p>Loading...</p>}\n      {!isLoading && (\n        <ul>\n          {tableData?.map((post) => (\n            <li key={post.id}>\n              <Link href={`/posts/show/${post.id}`}>{post.title}</Link>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  )\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/posts/show/[id].tsx",title:"pages/posts/show/[id].tsx"},'import { useShow } from "@refinedev/core";\n\ntype IPost = {\n    id: string;\n    title: string;\n    description: string;\n}\n\nexport default function PostShow() {\n    // `posts` resource and the `id` will be inferred from the route.\n    // Because we\'ve defined `/posts/show/:id` as the `show` action of the `posts` resource.\n    const { queryResult: { data, isLoading } } = useShow<IPost>();\n\n    const postData = data?.data;\n\n    return (\n        <div>\n            {isLoading && <p>Loading...</p>}\n            {!isLoading && (\n                <h1>{postData?.title}</h1>\n                <p>{postData?.description}</p>\n            )}\n        </div>\n    );\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/categories/index.tsx",title:"pages/categories/index.tsx"},"import { useTable } from '@refinedev/core'\nimport Link from 'next/link'\n\ntype ICategory = {\n  id: string\n  label: string\n}\n\nexport default function CategoryList() {\n  // `categories` resource will be inferred from the route.\n  // Because we've defined `/categories` as the `list` action of the `categories` resource.\n  const {\n    tableQueryResult: { data, isLoading },\n  } = useTable<ICategory>()\n\n  const tableData = data?.data\n\n  return (\n    <div>\n      {isLoading && <p>Loading...</p>}\n      {!isLoading && (\n        <ul>\n          {tableData?.map((category) => (\n            <li key={category.id}>\n              <Link href={`/categories/show/${category.id}`}>\n                {category.label}\n              </Link>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  )\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/categories/show/[id].tsx",title:"pages/categories/show/[id].tsx"},"import { useShow } from '@refinedev/core'\n\ntype ICategory = {\n  id: string\n  label: string\n}\n\nexport default function CategoryShow() {\n  // `categories` resource and the `id` will be inferred from the route.\n  // Because we've defined `/categories/show/:id` as the `show` action of the `categories` resource.\n  const {\n    queryResult: { data, isLoading },\n  } = useShow<ICategory>()\n\n  const categoryData = data?.data\n\n  return (\n    <div>\n      <h1>{categoryData?.label}</h1>\n    </div>\n  )\n}\n")),(0,r.kt)("p",null,"Now, we'll use ",(0,r.kt)("a",{parentName:"p",href:"#navigatetoresource"},(0,r.kt)("inlineCode",{parentName:"a"},"NavigateToResource"))," component to redirect to the ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource when the user visits the home page."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Even though we're using the ",(0,r.kt)("inlineCode",{parentName:"p"},"NavigateToResource")," component, when using Next.js it's better to handle such redirect operations in the server side rather than the client side. You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"getServerSideProps")," function to redirect the user to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/index.tsx",title:"pages/index.tsx"},"import { NavigateToResource } from '@refinedev/nextjs-router'\n\nexport default function Home() {\n  return <NavigateToResource />\n}\n")),(0,r.kt)("h3",{id:"app-directory"},(0,r.kt)("inlineCode",{parentName:"h3"},"/app")," Directory"),(0,r.kt)("p",null,"We'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/nextjs-router/app")," to set up the router bindings for ",(0,r.kt)("strong",{parentName:"p"},"refine"),". We'll define the action routes for our resources in the ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," array and define our pages in the ",(0,r.kt)("inlineCode",{parentName:"p"},"app")," directory."),(0,r.kt)("p",null,"We'll create four routes for our resources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"app/posts/page.tsx")," - List page for posts"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"app/posts/show/[id]/page.tsx")," - Detail page for posts"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"app/categories/page.tsx")," - List page for categories"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"app/categories/show/[id]/page.tsx")," - Detail page for categories")),(0,r.kt)("p",null,"And we'll create one route for the index and use it to redirect to the ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"app/page.tsx")," - Index page")),(0,r.kt)("p",null,"Let's start with the initialization of the ",(0,r.kt)("strong",{parentName:"p"},"refine")," app in the ",(0,r.kt)("inlineCode",{parentName:"p"},"app/layout.tsx")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/layout.tsx",title:"app/layout.tsx"},"'use client'\n\nimport { Refine } from '@refinedev/core'\nimport dataProvider from '@refinedev/simple-rest'\nimport routerProvider from '@refinedev/nextjs-router/app'\n\nimport { Layout } from 'components/Layout'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <Refine\n          dataProvider={dataProvider('https://api.fake-rest.refine.dev')}\n          // highlight-next-line\n          routerProvider={routerProvider}\n          resources={[\n            {\n              name: 'posts',\n              list: '/posts',\n              show: '/posts/show/:id',\n            },\n            {\n              name: 'categories',\n              list: '/categories',\n              show: '/categories/show/:id',\n            },\n          ]}\n        >\n          {/* We're defining `Layout` here but you might want to have different layouts per your page. */}\n          {/* This is totally fine for refine, you can place your Layout wherever you like. */}\n          <Layout>{children}</Layout>\n        </Refine>\n      </body>\n    </html>\n  )\n}\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Next.js uses the bracket syntax (",(0,r.kt)("inlineCode",{parentName:"p"},"[param]"),") for dynamic routes but ",(0,r.kt)("strong",{parentName:"p"},"refine")," uses the colon syntax (",(0,r.kt)("inlineCode",{parentName:"p"},":param"),") for route parameters. This won't cause any problems since ",(0,r.kt)("strong",{parentName:"p"},"refine")," only uses the colon syntax as an indicator for route parameters and the communication between ",(0,r.kt)("strong",{parentName:"p"},"refine")," and the router is handled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"routerProvider")," prop.")),(0,r.kt)("admonition",{title:"Additional Parameters and Nesting",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Your action definitions in the resources can contain additional parameters and nested routes. Passing these parameters when navigating to the pages are handled by the current available parameters and the ",(0,r.kt)("inlineCode",{parentName:"p"},"meta")," props of the related hooks and components."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"refine")," supports route parameters defined with ",(0,r.kt)("inlineCode",{parentName:"p"},":param")," syntax. You can use these parameters in your action definitions and create your routes accordingly. For example, if you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource and you want to create a route for the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," action of a specific post, you can define the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," action as ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts/show/:id")," and use the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," parameter in your component.")),(0,r.kt)("p",null,"Now we can create our pages in the ",(0,r.kt)("inlineCode",{parentName:"p"},"app")," directory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/posts/page.tsx",title:"app/posts/page.tsx"},"'use client'\n\nimport { useTable } from '@refinedev/core'\nimport Link from 'next/link'\n\ntype IPost = {\n  id: string\n  title: string\n  description: string\n}\n\nexport default function PostList() {\n  // `posts` resource will be inferred from the route.\n  // Because we've defined `/posts` as the `list` action of the `posts` resource.\n  const {\n    tableQueryResult: { data, isLoading },\n  } = useTable<IPost>()\n\n  const tableData = data?.data\n\n  return (\n    <div>\n      {isLoading && <p>Loading...</p>}\n      {!isLoading && (\n        <ul>\n          {tableData?.map((post) => (\n            <li key={post.id}>\n              <Link href={`/posts/show/${post.id}`}>{post.title}</Link>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  )\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/posts/show/[id]/page.tsx",title:"pages/posts/show/[id]/page.tsx"},'"use client";\n\nimport { useShow } from "@refinedev/core";\n\ntype IPost = {\n    id: string;\n    title: string;\n    description: string;\n}\n\nexport default function PostShow() {\n    // `posts` resource and the `id` will be inferred from the route.\n    // Because we\'ve defined `/posts/show/:id` as the `show` action of the `posts` resource.\n    const { queryResult: { data, isLoading } } = useShow<IPost>();\n\n    const postData = data?.data;\n\n    return (\n        <div>\n            {isLoading && <p>Loading...</p>}\n            {!isLoading && (\n                <h1>{postData?.title}</h1>\n                <p>{postData?.description}</p>\n            )}\n        </div>\n    );\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/categories/page.tsx",title:"pages/categories/page.tsx"},"'use client'\n\nimport { useTable } from '@refinedev/core'\nimport Link from 'next/link'\n\ntype ICategory = {\n  id: string\n  label: string\n}\n\nexport default function CategoryList() {\n  // `categories` resource will be inferred from the route.\n  // Because we've defined `/categories` as the `list` action of the `categories` resource.\n  const {\n    tableQueryResult: { data, isLoading },\n  } = useTable<ICategory>()\n\n  const tableData = data?.data\n\n  return (\n    <div>\n      {isLoading && <p>Loading...</p>}\n      {!isLoading && (\n        <ul>\n          {tableData?.map((category) => (\n            <li key={category.id}>\n              <Link href={`/categories/show/${category.id}`}>\n                {category.label}\n              </Link>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  )\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/categories/show/[id]/page.tsx",title:"pages/categories/show/[id]/page.tsx"},"'use client'\n\nimport { useShow } from '@refinedev/core'\n\ntype ICategory = {\n  id: string\n  label: string\n}\n\nexport default function CategoryShow() {\n  // `categories` resource and the `id` will be inferred from the route.\n  // Because we've defined `/categories/show/:id` as the `show` action of the `categories` resource.\n  const {\n    queryResult: { data, isLoading },\n  } = useShow<ICategory>()\n\n  const categoryData = data?.data\n\n  return (\n    <div>\n      <h1>{categoryData?.label}</h1>\n    </div>\n  )\n}\n")),(0,r.kt)("p",null,"Now, we'll use ",(0,r.kt)("a",{parentName:"p",href:"#navigatetoresource"},(0,r.kt)("inlineCode",{parentName:"a"},"NavigateToResource"))," component to redirect to the ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," resource when the user visits the home page."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Even though we're using the ",(0,r.kt)("inlineCode",{parentName:"p"},"NavigateToResource")," component, when using Next.js it's better to handle such redirect operations in the server side rather than the client side. You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"getServerSideProps")," function to redirect the user to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/posts"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/page.tsx",title:"app/page.tsx"},"import { NavigateToResource } from '@refinedev/nextjs-router/app'\n\nexport default function IndexPage() {\n  return <NavigateToResource />\n}\n")),(0,r.kt)("h2",{id:"additional-components"},"Additional Components"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/nextjs-router")," package also includes some additional components that can be useful in some cases."),(0,r.kt)("h3",{id:"navigatetoresource"},(0,r.kt)("inlineCode",{parentName:"h3"},"NavigateToResource")),(0,r.kt)("p",null,"A basic component to navigate to a resource page. It is useful when you want to navigate to a resource page at the index route of your app."),(0,r.kt)("h4",{id:"in-pagesindextsx"},"In ",(0,r.kt)("inlineCode",{parentName:"h4"},"pages/index.tsx")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/index.tsx",title:"pages/index.tsx"},"import { NavigateToResource } from '@refinedev/nextjs-router'\n\nexport default function IndexPage() {\n  return <NavigateToResource />\n}\n")),(0,r.kt)("h4",{id:"in-apppagetsx"},"In ",(0,r.kt)("inlineCode",{parentName:"h4"},"app/page.tsx")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/page.tsx",title:"app/page.tsx"},"'use client'\n\nimport { NavigateToResource } from '@refinedev/nextjs-router/app'\n\nexport default function IndexPage() {\n  return <NavigateToResource />\n}\n")),(0,r.kt)("h4",{id:"properties"},"Properties"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"resource")," (optional) - The name of the resource to navigate to. It will redirect to the first ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," route in the ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," array if not provided."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"meta")," (optional) - The meta object to use if the route has parameters in it. The parameters in the current location will also be used to compose the route but ",(0,r.kt)("inlineCode",{parentName:"p"},"meta")," will take precedence."),(0,r.kt)("h3",{id:"unsavedchangesnotifier"},(0,r.kt)("inlineCode",{parentName:"h3"},"UnsavedChangesNotifier")),(0,r.kt)("p",null,"This component enables the ",(0,r.kt)("inlineCode",{parentName:"p"},"warnWhenUnsavedChanges")," feature of ",(0,r.kt)("strong",{parentName:"p"},"refine"),". It will show a warning message when user tries to navigate away from the current page without saving the changes. Also checks for ",(0,r.kt)("inlineCode",{parentName:"p"},"beforeunload")," event to warn the user when they try to close the browser tab or window."),(0,r.kt)("p",null,"Place this component inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Refine>")," components children to enable this feature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=_app.tsx",title:"_app.tsx"},"import { Refine } from '@refinedev/core'\nimport { UnsavedChangesNotifier } from '@refinedev/nextjs-router'\n\nfunction App({ Component, pageProps }: AppProps): JSX.Element {\n  return (\n    <Refine\n    /* ... */\n    >\n      <Component {...pageProps} />\n      {/* highlight-next-line */}\n      <UnsavedChangesNotifier />\n    </Refine>\n  )\n}\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This feature is not working in experimental ",(0,r.kt)("inlineCode",{parentName:"p"},"appDir")," mode in Next.js due to limitations of the ",(0,r.kt)("inlineCode",{parentName:"p"},"next/navigation")," and missing events.")),(0,r.kt)("h4",{id:"properties-1"},"Properties"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"translationKey")," (optional) - The translation key for the warning message. Default value is ",(0,r.kt)("inlineCode",{parentName:"p"},"warnWhenUnsavedChanges"),". Useful when you use an i18n provider."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"message")," (optional) - The warning message. Default value is ",(0,r.kt)("inlineCode",{parentName:"p"},"Are you sure you want to leave? You have unsaved changes.")," Useful when you don't use an i18n provider."),(0,r.kt)("h3",{id:"parsetableparams"},(0,r.kt)("inlineCode",{parentName:"h3"},"parseTableParams")),(0,r.kt)("p",null,"This function can be used to parse the query parameters of a table page. It can be useful when you want to use the query parameters in your server side functions (",(0,r.kt)("inlineCode",{parentName:"p"},"loader"),") to fetch the data such as ",(0,r.kt)("a",{parentName:"p",href:"#how-to-persist-syncwithlocation-in-ssr"},"persisting the table state")),(0,r.kt)("h2",{id:"authentication"},"Authentication"),(0,r.kt)("p",null,"In Next.js you can achieve authentication control in multiple ways;"),(0,r.kt)("p",null,"On the client-side, you can wrap your pages with ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/components/auth/authenticated/"},(0,r.kt)("inlineCode",{parentName:"a"},"Authenticated"))," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/core")," to protect your pages from unauthenticated access."),(0,r.kt)("p",null,"On the server-side, you can use your ",(0,r.kt)("inlineCode",{parentName:"p"},"authProvider"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"check")," function inside server side functions (",(0,r.kt)("inlineCode",{parentName:"p"},"getServerSideProps"),") to redirect unauthenticated users to other pages like login..."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"For page level authentication, server-side approach is recommended.")),(0,r.kt)("h3",{id:"server-side"},"Server Side"),(0,r.kt)("p",null,"First, let's install the ",(0,r.kt)("inlineCode",{parentName:"p"},"nookies")," packages in our project."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"npm i nookies\n")),(0,r.kt)("p",null,"We will set/destroy cookies in the ",(0,r.kt)("inlineCode",{parentName:"p"},"login"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"logout")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"check")," functions of our ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthProvider"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/authProvider.ts"',title:'"app/authProvider.ts"'},"import { AuthBindings } from '@refinedev/core'\n// highlight-start\nimport nookies from 'nookies'\n// highlight-end\n\nconst mockUsers = [\n  {\n    username: 'admin',\n    roles: ['admin'],\n  },\n  {\n    username: 'editor',\n    roles: ['editor'],\n  },\n]\n\n// highlight-next-line\nconst COOKIE_NAME = 'user'\n\nexport const authProvider: AuthBindings = {\n  login: ({ username, password, remember }) => {\n    // Suppose we actually send a request to the back end here.\n    const user = mockUsers.find((item) => item.username === username)\n\n    if (user) {\n      // highlight-start\n      nookies.set(null, COOKIE_NAME, JSON.stringify(user), {\n        maxAge: remember ? 30 * 24 * 60 * 60 : undefined,\n      })\n      // highlight-end\n\n      return {\n        success: true,\n      }\n    }\n\n    return {\n      success: false,\n    }\n  },\n  logout: () => {\n    // highlight-next-line\n    nookies.destroy(null, COOKIE_NAME)\n\n    return {\n      success: true,\n      redirectTo: '/login',\n    }\n  },\n  onError: (error) => {\n    if (error && error.statusCode === 401) {\n      return {\n        error: new Error('Unauthorized'),\n        logout: true,\n        redirectTo: '/login',\n      }\n    }\n\n    return {}\n  },\n  check: async (context) => {\n    // highlight-start\n    let user = undefined\n    if (context) {\n      // for SSR\n      const cookies = nookies.get(context)\n      user = cookies[COOKIE_NAME]\n    } else {\n      // for CSR\n      const cookies = nookies.get(null)\n      user = cookies[COOKIE_NAME]\n    }\n    // highlight-end\n\n    if (!user) {\n      return {\n        authenticated: false,\n        error: {\n          message: 'Check failed',\n          name: 'Unauthorized',\n        },\n        logout: true,\n        redirectTo: '/login',\n      }\n    }\n\n    return {\n      authenticated: true,\n    }\n  },\n  getPermissions: async () => {\n    return null\n  },\n  getIdentity: async () => {\n    return null\n  },\n}\n")),(0,r.kt)("p",null,"Tadaa! that's all! \ud83c\udf89"),(0,r.kt)("p",null,"Now, we can check the authentication in loaders of our routes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/posts/index.tsx"',title:'"pages/posts/index.tsx"'},"import { authProvider } from 'src/authProvider'\n\nexport const getServerSideProps = async (context) => {\n  // We've handled the SSR case in our `check` function by sending the `context` as parameter.\n  const { authenticated, redirectTo } = await authProvider.check(context)\n\n  if (!authenticated) {\n    context.res.statusCode = 401\n    context.res.end()\n  }\n\n  if (!authenticated && redirectTo) {\n    return {\n      redirect: {\n        destination: redirectTo,\n        permanent: false,\n      },\n    }\n  }\n\n  return {\n    props: {\n      authenticated,\n    },\n  }\n}\n")),(0,r.kt)("p",null,"This needs to be done for all the routes that we want to protect."),(0,r.kt)("h2",{id:"access-control"},"Access Control"),(0,r.kt)("p",null,"In Next.js you can achieve access control in multiple ways;"),(0,r.kt)("p",null,"On the client-side you can wrap your pages with ",(0,r.kt)("inlineCode",{parentName:"p"},"CanAccess")," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/core")," to protect your pages from unauthorized access."),(0,r.kt)("p",null,"And on the server-side you can use your ",(0,r.kt)("inlineCode",{parentName:"p"},"accessControlProvider"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"can")," function inside server side functions (",(0,r.kt)("inlineCode",{parentName:"p"},"getServerSideProps"),") to redirect unauthorized users to other pages.."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"For page level access control, server-side approach is recommended.")),(0,r.kt)("h3",{id:"server-side-1"},"Server Side"),(0,r.kt)("p",null,"On the server side, you can use your ",(0,r.kt)("inlineCode",{parentName:"p"},"accessControlProvider"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"can")," function inside ",(0,r.kt)("inlineCode",{parentName:"p"},"getServerSideProps")," to redirect unauthorized users to other pages."),(0,r.kt)("p",null,"First, let's build our ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/providers/accessControl-provider"},"AccessControlProvider")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/acccessControlProvider.ts"',title:'"app/acccessControlProvider.ts"'},"export const accessControlProvider = {\n  can: async ({ resource, action, params }) => {\n    if (resource === 'posts' && action === 'edit') {\n      return {\n        can: false,\n        reason: 'Unauthorized',\n      }\n    }\n\n    return { can: true }\n  },\n}\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can also access resource object directly.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"export const accessControlProvider = {\n  can: async ({ resource, action, params }) => {\n    const resourceName = params?.resource?.name\n    const anyUsefulMeta = params?.resource?.meta?.yourUsefulMeta\n\n    if (\n      resourceName === 'posts' &&\n      anyUsefulMeta === true &&\n      action === 'edit'\n    ) {\n      return {\n        can: false,\n        reason: 'Unauthorized',\n      }\n    }\n  },\n}\n")),(0,r.kt)("p",null,"Then, let's create our posts page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/posts/index.tsx"',title:'"pages/posts/index.tsx"'},"import { accessControlProvider } from 'src/accessControlProvider'\n\nexport const getServerSideProps = async (context) => {\n  const { can } = await accessControlProvider.can({\n    resource: 'posts',\n    action: 'list',\n  })\n\n  if (!can) {\n    context.res.statusCode = 403\n    context.res.end()\n  }\n\n  return {\n    props: {\n      can,\n    },\n  }\n}\n\nexport default function PostList() {\n  /* ... */\n}\n")),(0,r.kt)("h3",{id:"client-side"},"Client Side"),(0,r.kt)("p",null,"For client-side, you can wrap your pages with ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/components/accessControl/can-access"},(0,r.kt)("inlineCode",{parentName:"a"},"CanAccess"))," component from ",(0,r.kt)("inlineCode",{parentName:"p"},"@refinedev/core")," to protect your pages from unauthorized access."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { CanAccess } from '@refinedev/core'\n\nexport const MyPage = () => (\n  <CanAccess>\n    <div>{/* ... */}</div>\n  </CanAccess>\n)\n")),(0,r.kt)("h2",{id:"faq"},"FAQ"),(0,r.kt)("h3",{id:"can-i-use-nested-routes"},"Can I use nested routes?"),(0,r.kt)("p",null,"Yes, you can use nested routes in your app. ",(0,r.kt)("strong",{parentName:"p"},"refine")," will match the routes depending on how you define the action paths in your resources. Additional parameters and nesting is supported. ",(0,r.kt)("strong",{parentName:"p"},"refine")," will not limit you and your router in route configuration, all you need to do is to pass the appropriate path to the related resource and the action in the ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," array (This is also optional but recommended due to the features it provides)."),(0,r.kt)("p",null,"You can use ",(0,r.kt)("inlineCode",{parentName:"p"},":param")," syntax to define parameters in your routes."),(0,r.kt)("h3",{id:"how-to-make-ssr-work"},"How to make SSR work?"),(0,r.kt)("p",null,"You can always use the methods provided from the ",(0,r.kt)("inlineCode",{parentName:"p"},"dataProvider")," to fetch data in your pages. To do this, you can both use ",(0,r.kt)("inlineCode",{parentName:"p"},"getServerSideProps")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"getStaticProps")," methods and pass the data to your page as a prop."),(0,r.kt)("p",null,"All you need to do is to pass the data as the ",(0,r.kt)("inlineCode",{parentName:"p"},"initialData")," to your data hooks using the ",(0,r.kt)("inlineCode",{parentName:"p"},"queryOptions")," prop."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useList } from '@refinedev/core'\n\nimport { dataProvider } from 'src/providers'\n\ntype IPost = {\n  id: number\n  title: string\n  description: string\n}\n\nexport const getServerSideProps = async () => {\n  const { data } = await dataProvider.getList<IPost>('posts', {\n    pagination: {\n      page: 1,\n      perPage: 10,\n    },\n  })\n\n  return {\n    props: {\n      posts: data,\n    },\n  }\n}\n\nexport default function Posts({ posts }: { posts: GetListResponse<IPost> }) {\n  const {\n    tableQueryResult: { data },\n  } = useTable<IPost>({\n    queryOptions: {\n      initialData: posts,\n    },\n  })\n\n  return <>{/* ... */}</>\n}\n")),(0,r.kt)("h3",{id:"how-to-persist-syncwithlocation-in-ssr"},"How to persist ",(0,r.kt)("inlineCode",{parentName:"h3"},"syncWithLocation")," in SSR?"),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"syncWithLocation")," is enabled, query parameters must be handled while doing SSR."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// highligt-next-line\nimport { parseTableParams } from '@refinedev/nextjs-router'\nimport dataProvider from '@refinedev/simple-rest'\n\nconst API_URL = 'https://api.fake-rest.refine.dev'\n\nexport const getServerSideProps = ({ params, resolvedUrl }) => {\n  const { resource } = params\n\n  // highligt-next-line\n  const tableParams = parseTableParams(resolvedUrl?.split('?')[1] ?? '')\n\n  try {\n    const data = await dataProvider(API_URL).getList({\n      resource: resource as string,\n      ...tableParams, // this includes `filters`, `sorters` and `pagination`\n    })\n\n    return {\n      props: {\n        initialData: data,\n      },\n    }\n  } catch (error) {\n    return {\n      props: {},\n    }\n  }\n}\nexport default function MyListPage({ initialData }) {\n  return <>{/* ... */}</>\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"parseTableParams")," parses the query string and returns query parameters(","[refer here for their interfaces][interfaces]","). They can be directly used for ",(0,r.kt)("inlineCode",{parentName:"p"},"dataProvider")," methods that accept them."),(0,r.kt)("h3",{id:"how-to-use-multiple-layouts"},"How to use multiple layouts?"),(0,r.kt)("p",null,"When using ",(0,r.kt)("inlineCode",{parentName:"p"},"/pages")," directory for your routes, you'll probably have a point where you need to use multiple layouts. For example, you may want to use a different layout for the login page. To achieve this, you can either use your ",(0,r.kt)("inlineCode",{parentName:"p"},"Layout")," wrappers in your pages or you can add extra properties to your page components to render the page with the specified layout."),(0,r.kt)("p",null,"Here's an example of how you can use additional properties to render different layouts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/login.tsx"',title:'"pages/login.tsx"'},"export default function Login() {\n  return (\n    <div>\n      <h1>Login</h1>\n    </div>\n  )\n}\n\nLogin.layout = 'auth'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/posts/index.tsx"',title:'"pages/posts/index.tsx"'},"export default function Posts() {\n  return <div>{/* ... */}</div>\n}\n\nPosts.layout = 'default'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/_app.tsx"',title:'"pages/_app.tsx"'},'import { AuthLayout, DefaultLayout } from "src/layouts";\n\nconst Layouts = {\n    auth: AuthLayout,\n    default: DefaultLayout,\n};\n\nexport default function MyApp({ Component, pageProps }) {\n    const Layout = Layouts[Component.layout ?? "default"];\n\n    return (\n        <Refine\n            {/* ... */}\n        >\n            <Layout>\n                <Component {...pageProps} />\n            </Layout>\n        </Refine>\n    );\n}\n')),(0,r.kt)("p",null,"To comply with TypeScript types, we'll need to extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"NextPage")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"AppProps")," types accordingly to expect the ",(0,r.kt)("inlineCode",{parentName:"p"},"layout")," property in page components."),(0,r.kt)("admonition",{title:"Read more at Next.js Docs",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"You can find out more about this at ",(0,r.kt)("a",{parentName:"p",href:"https://nextjs.org/docs/basic-features/layouts#with-typescript"},"Next.js documentation for multiple layouts"))),(0,r.kt)("p",null,"We'll define the types in ",(0,r.kt)("inlineCode",{parentName:"p"},"_app.tsx")," file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/_app.tsx"',title:'"pages/_app.tsx"'},"import type { NextPage } from 'next'\nimport type { AppProps } from 'next/app'\n\nexport type PageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {\n  layout?: keyof typeof Layouts\n}\n\ntype AppPropsWithLayout = AppProps & {\n  Component: PageWithLayout\n}\n\n// Then we'll change the type of `MyApp` components props to `AppPropsWithLayout`.\nexport default function MyApp({ Component, pageProps }: AppPropsWithLayout) {\n  /* ... */\n}\n")),(0,r.kt)("p",null,"Then in our pages, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"PageWithLayout")," type when defining our page components."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/login.tsx"',title:'"pages/login.tsx"'},"import type { PageWithLayout } from 'pages/_app'\n\nconst Login: PageWithLayout = () => {\n  return (\n    <div>\n      <h1>Login</h1>\n    </div>\n  )\n}\n\nLogin.layout = 'auth'\n")),(0,r.kt)("h3",{id:"handling-404s"},"Handling 404s"),(0,r.kt)("p",null,"In the earlier versions of ",(0,r.kt)("strong",{parentName:"p"},"refine"),", if ",(0,r.kt)("inlineCode",{parentName:"p"},"authProvider")," was defined, we've redirected the users to the ",(0,r.kt)("inlineCode",{parentName:"p"},"/login")," route even with the 404s and 404 pages were only available to the authenticated users. Now, the routes are handled by the users, so you can handle the 404s however you like."),(0,r.kt)("h4",{id:"using-the-nextjss-404-page"},"Using the Next.js's 404 page"),(0,r.kt)("p",null,"If you want to use the Next.js's 404 page, you can create a ",(0,r.kt)("inlineCode",{parentName:"p"},"404.tsx")," file in your ",(0,r.kt)("inlineCode",{parentName:"p"},"/pages")," directory and it will be used as the 404 page. For more information, you can check the ",(0,r.kt)("a",{parentName:"p",href:"https://nextjs.org/docs/advanced-features/custom-error-page#404-page"},"Next.js documentation for custom 404 page"),"."),(0,r.kt)("h4",{id:"using-a-catch-all-route"},"Using a catch-all route"),(0,r.kt)("p",null,"If you want to achieve the legacy behavior or want to have more control over the unhandled routes, you can use the catch-all route. For more information, you can check the ",(0,r.kt)("a",{parentName:"p",href:"https://nextjs.org/docs/routing/dynamic-routes#optional-catch-all-routes"},"Next.js documentation for catch-all route"),"."),(0,r.kt)("p",null,"You can use ",(0,r.kt)("strong",{parentName:"p"},"refine"),"'s authentication hooks and the ",(0,r.kt)("inlineCode",{parentName:"p"},"authProvider")," to check if the user is authenticated or not and redirect them to the login page. This check can be done on the client-side or server-side."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Client Side")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/[...slug].tsx"',title:'"pages/[...slug].tsx"'},"import { Authenticated } from '@refinedev/core'\n\nexport default function CatchAll() {\n  return (\n    // This will redirect the user if they're not authenticated depending on the response of `authProvider.check`.\n    <Authenticated>\n      <div>This page is not found.</div>\n    </Authenticated>\n  )\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Server Side")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="pages/[...slug].tsx"',title:'"pages/[...slug].tsx"'},"import { authProvider } from 'src/authProvider'\n\nexport const getServerSideProps = async (context) => {\n  const { authenticated, redirectTo } = await authProvider.check(context)\n\n  if (!authenticated && redirectTo) {\n    return {\n      redirect: {\n        destination: redirectTo,\n        permanent: false,\n      },\n      props: {},\n    }\n  }\n\n  return {\n    props: {},\n  }\n}\n\nexport default function CatchAll() {\n  return <div>This page is not found.</div>\n}\n")),(0,r.kt)("h3",{id:"refineroutes-component"},(0,r.kt)("inlineCode",{parentName:"h3"},"RefineRoutes")," Component"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"While this may work for the simple cases, it is not recommended to use this component. Defining your routes separately will give you more control over your routes and will allow you to use the full potential of your router.")),(0,r.kt)("p",null,"This component can be used to render the matching route in your resources by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"resources")," prop. It will only take effect if the action properties in the resource definitions are assigned to components or objects with ",(0,r.kt)("inlineCode",{parentName:"p"},"component")," property."),(0,r.kt)("p",null,"It will render the component for the matching route and pass it as a ",(0,r.kt)("inlineCode",{parentName:"p"},"JSX.Element")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"children")," function. You can use this to render your components in a single catch-all route. If there's no matching route ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," will be passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"children")," function. In this case, you can render an error page or redirect the user to another page."),(0,r.kt)("p",null,"We'll define our resources in the ",(0,r.kt)("inlineCode",{parentName:"p"},"<Refine>")," component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"return (\n  <Refine\n    resources={[\n      {\n        name: 'posts',\n        list: '/posts',\n        show: '/posts/show/:id',\n      },\n      {\n        name: 'categories',\n        list: '/categories',\n      },\n    ]}\n  >\n    {/* ... */}\n  </Refine>\n)\n")),(0,r.kt)("p",null,"Then, we'll create a catch-all route to render the matching route in our resources:"),(0,r.kt)("h4",{id:"in-pagesrefinetsx"},"In ",(0,r.kt)("inlineCode",{parentName:"h4"},"pages/[[...refine]].tsx")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=pages/[[...refine]].tsx",title:"pages/[[...refine]].tsx"},"import { RefineRoutes } from '@refinedev/nextjs-router'\n\nimport { ErrorPage } from 'components/error'\n\nexport default function CatchAll() {\n  return (\n    <RefineRoutes>\n      {(matchingRoute) => {\n        if (matchingRoute) {\n          return { matchingRoute }\n        }\n\n        return <ErrorPage />\n      }}\n    </RefineRoutes>\n  )\n}\n")),(0,r.kt)("h4",{id:"in-apprefinepagetsx"},"In ",(0,r.kt)("inlineCode",{parentName:"h4"},"app/[[...refine]]/page.tsx")),(0,r.kt)("p",null,"If you're using experimental ",(0,r.kt)("inlineCode",{parentName:"p"},"appDir")," in your Next.js project, you can create a catch-all route in the ",(0,r.kt)("inlineCode",{parentName:"p"},"app")," directory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/[[...refine]]/page.tsx",title:"app/[[...refine]]/page.tsx"},"'use client'\n\nimport { RefineRoutes } from '@refinedev/nextjs-router/app'\n\nexport default function CatchAll() {\n  return (\n    <RefineRoutes>\n      {(matchingRoute) => {\n        if (matchingRoute) {\n          return { matchingRoute }\n        }\n\n        return <ErrorPage />\n      }}\n    </RefineRoutes>\n  )\n}\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"When components are used to define the resource actions, default paths will be used. You can override the default paths by assigning an object with ",(0,r.kt)("inlineCode",{parentName:"p"},"component")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"path")," properties to the action properties."),(0,r.kt)("p",{parentName:"admonition"},"Default paths are:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"list"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"/resources")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"create"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"/resources/create")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edit"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"/resources/edit/:id")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"show"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"/resources/show/:id"),"\n:::")),(0,r.kt)("h2",{parentName:"admonition",id:"example-pages"},"Example (",(0,r.kt)("inlineCode",{parentName:"h2"},"/pages"),")"),(0,r.kt)(d,{path:"with-nextjs",mdxType:"CodeSandboxExample"}),(0,r.kt)("h2",{parentName:"admonition",id:"example-app"},"Example (",(0,r.kt)("inlineCode",{parentName:"h2"},"/app"),")"),(0,r.kt)(d,{path:"with-nextjs-appdir",mdxType:"CodeSandboxExample"})))}h.isMDXComponent=!0}}]);